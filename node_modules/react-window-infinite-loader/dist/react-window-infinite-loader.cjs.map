{"version":3,"file":"react-window-infinite-loader.cjs","sources":["../src/scanForUnloadedIndices.ts","../src/useInfiniteLoader.ts","../src/InfiniteLoader.ts"],"sourcesContent":["import type { Indices } from \"./types\";\n\nexport function scanForUnloadedIndices({\n  isRowLoaded,\n  minimumBatchSize,\n  rowCount,\n  startIndex,\n  stopIndex,\n}: {\n  isRowLoaded: (index: number) => boolean;\n  minimumBatchSize: number;\n  rowCount: number;\n  startIndex: number;\n  stopIndex: number;\n}): Indices[] {\n  const indices: Indices[] = [];\n\n  let currentStartIndex = -1;\n  let currentStopIndex = -1;\n\n  for (let index = startIndex; index <= stopIndex; index++) {\n    if (!isRowLoaded(index)) {\n      currentStopIndex = index;\n      if (currentStartIndex < 0) {\n        currentStartIndex = index;\n      }\n    } else if (currentStopIndex >= 0) {\n      indices.push({\n        startIndex: currentStartIndex,\n        stopIndex: currentStopIndex,\n      });\n\n      currentStartIndex = currentStopIndex = -1;\n    }\n  }\n\n  // Scan forward to satisfy the minimum batch size.\n  if (currentStopIndex >= 0) {\n    const potentialStopIndex = Math.min(\n      Math.max(currentStopIndex, currentStartIndex + minimumBatchSize - 1),\n      rowCount - 1\n    );\n\n    for (\n      let index = currentStopIndex + 1;\n      index <= potentialStopIndex;\n      index++\n    ) {\n      if (!isRowLoaded(index)) {\n        currentStopIndex = index;\n      } else {\n        break;\n      }\n    }\n\n    indices.push({\n      startIndex: currentStartIndex,\n      stopIndex: currentStopIndex,\n    });\n  }\n\n  // Check to see if our first range ended prematurely.\n  // In this case we should scan backwards to satisfy the minimum batch size.\n  if (indices.length) {\n    const firstIndices = indices[0];\n    while (\n      firstIndices.stopIndex - firstIndices.startIndex + 1 < minimumBatchSize &&\n      firstIndices.startIndex > 0\n    ) {\n      const index = firstIndices.startIndex - 1;\n      if (!isRowLoaded(index)) {\n        firstIndices.startIndex = index;\n      } else {\n        break;\n      }\n    }\n  }\n\n  return indices;\n}\n","import { useCallback, useMemo } from \"react\";\nimport { scanForUnloadedIndices } from \"./scanForUnloadedIndices\";\nimport type { Indices, OnRowsRendered, Props } from \"./types\";\n\nexport function useInfiniteLoader({\n  isRowLoaded,\n  loadMoreRows,\n  minimumBatchSize = 10,\n  rowCount,\n  threshold = 15,\n}: Props) {\n  const pendingRowsCache = useMemo(() => {\n    void isRowLoaded;\n    void loadMoreRows;\n\n    return new Set();\n  }, [isRowLoaded, loadMoreRows]);\n\n  const isRowLoadedOrPending = useCallback(\n    (index: number) => {\n      if (isRowLoaded(index)) {\n        return true;\n      }\n\n      return pendingRowsCache.has(index);\n    },\n    [isRowLoaded, pendingRowsCache]\n  );\n\n  const onRowsRendered = useCallback<OnRowsRendered>(\n    ({ startIndex, stopIndex }: Indices) => {\n      const unloadedIndices = scanForUnloadedIndices({\n        isRowLoaded: isRowLoadedOrPending,\n        minimumBatchSize,\n        rowCount,\n        startIndex: Math.max(0, startIndex - threshold),\n        stopIndex: Math.min(rowCount - 1, stopIndex + threshold),\n      });\n\n      for (let index = 0; index < unloadedIndices.length; index += 2) {\n        const { startIndex: unloadedStartIndex, stopIndex: unloadedStopIndex } =\n          unloadedIndices[index];\n\n        for (\n          let index = unloadedStartIndex;\n          index <= unloadedStopIndex;\n          index++\n        ) {\n          pendingRowsCache.add(index);\n        }\n\n        loadMoreRows(unloadedStartIndex, unloadedStopIndex);\n      }\n    },\n    [\n      isRowLoadedOrPending,\n      loadMoreRows,\n      minimumBatchSize,\n      pendingRowsCache,\n      rowCount,\n      threshold,\n    ]\n  );\n\n  return onRowsRendered;\n}\n","import type { OnRowsRendered, Props } from \"./types\";\nimport { useInfiniteLoader } from \"./useInfiniteLoader\";\n\nexport function InfiniteLoader({\n  children,\n  ...props\n}: Props & {\n  children: (paras: { onRowsRendered: OnRowsRendered }) => void;\n}) {\n  const onRowsRendered = useInfiniteLoader(props);\n\n  return children({ onRowsRendered });\n}\n"],"names":["scanForUnloadedIndices","isRowLoaded","minimumBatchSize","rowCount","startIndex","stopIndex","indices","currentStartIndex","currentStopIndex","index","potentialStopIndex","firstIndices","useInfiniteLoader","loadMoreRows","threshold","pendingRowsCache","useMemo","isRowLoadedOrPending","useCallback","unloadedIndices","unloadedStartIndex","unloadedStopIndex","InfiniteLoader","children","props","onRowsRendered"],"mappings":"yGAEO,SAASA,EAAuB,CACrC,YAAAC,EACA,iBAAAC,EACA,SAAAC,EACA,WAAAC,EACA,UAAAC,CACF,EAMc,CACZ,MAAMC,EAAqB,CAAA,EAE3B,IAAIC,EAAoB,GACpBC,EAAmB,GAEvB,QAASC,EAAQL,EAAYK,GAASJ,EAAWI,IAC1CR,EAAYQ,CAAK,EAKXD,GAAoB,IAC7BF,EAAQ,KAAK,CACX,WAAYC,EACZ,UAAWC,CAAA,CACZ,EAEDD,EAAoBC,EAAmB,KAVvCA,EAAmBC,EACfF,EAAoB,IACtBA,EAAoBE,IAa1B,GAAID,GAAoB,EAAG,CACzB,MAAME,EAAqB,KAAK,IAC9B,KAAK,IAAIF,EAAkBD,EAAoBL,EAAmB,CAAC,EACnEC,EAAW,CAAA,EAGb,QACMM,EAAQD,EAAmB,EAC/BC,GAASC,GAGL,CAACT,EAAYQ,CAAK,EAFtBA,IAGED,EAAmBC,EAMvBH,EAAQ,KAAK,CACX,WAAYC,EACZ,UAAWC,CAAA,CACZ,CACH,CAIA,GAAIF,EAAQ,OAAQ,CAClB,MAAMK,EAAeL,EAAQ,CAAC,EAC9B,KACEK,EAAa,UAAYA,EAAa,WAAa,EAAIT,GACvDS,EAAa,WAAa,GAC1B,CACA,MAAMF,EAAQE,EAAa,WAAa,EACxC,GAAI,CAACV,EAAYQ,CAAK,EACpBE,EAAa,WAAaF,MAE1B,MAEJ,CACF,CAEA,OAAOH,CACT,CC3EO,SAASM,EAAkB,CAChC,YAAAX,EACA,aAAAY,EACA,iBAAAX,EAAmB,GACnB,SAAAC,EACA,UAAAW,EAAY,EACd,EAAU,CACR,MAAMC,EAAmBC,EAAAA,QAAQ,QAIpB,IACV,CAACf,EAAaY,CAAY,CAAC,EAExBI,EAAuBC,EAAAA,YAC1BT,GACKR,EAAYQ,CAAK,EACZ,GAGFM,EAAiB,IAAIN,CAAK,EAEnC,CAACR,EAAac,CAAgB,CAAA,EAsChC,OAnCuBG,EAAAA,YACrB,CAAC,CAAE,WAAAd,EAAY,UAAAC,KAAyB,CACtC,MAAMc,EAAkBnB,EAAuB,CAC7C,YAAaiB,EACb,iBAAAf,EACA,SAAAC,EACA,WAAY,KAAK,IAAI,EAAGC,EAAaU,CAAS,EAC9C,UAAW,KAAK,IAAIX,EAAW,EAAGE,EAAYS,CAAS,CAAA,CACxD,EAED,QAASL,EAAQ,EAAGA,EAAQU,EAAgB,OAAQV,GAAS,EAAG,CAC9D,KAAM,CAAE,WAAYW,EAAoB,UAAWC,CAAA,EACjDF,EAAgBV,CAAK,EAEvB,QACMA,EAAQW,EACZX,GAASY,EACTZ,IAEAM,EAAiB,IAAIN,CAAK,EAG5BI,EAAaO,EAAoBC,CAAiB,CACpD,CACF,EACA,CACEJ,EACAJ,EACAX,EACAa,EACAZ,EACAW,CAAA,CACF,CAIJ,CC9DO,SAASQ,EAAe,CAC7B,SAAAC,EACA,GAAGC,CACL,EAEG,CACD,MAAMC,EAAiBb,EAAkBY,CAAK,EAE9C,OAAOD,EAAS,CAAE,eAAAE,EAAgB,CACpC"}