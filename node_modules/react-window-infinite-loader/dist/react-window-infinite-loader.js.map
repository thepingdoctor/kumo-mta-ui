{"version":3,"file":"react-window-infinite-loader.js","sources":["../src/scanForUnloadedIndices.ts","../src/useInfiniteLoader.ts","../src/InfiniteLoader.ts"],"sourcesContent":["import type { Indices } from \"./types\";\n\nexport function scanForUnloadedIndices({\n  isRowLoaded,\n  minimumBatchSize,\n  rowCount,\n  startIndex,\n  stopIndex,\n}: {\n  isRowLoaded: (index: number) => boolean;\n  minimumBatchSize: number;\n  rowCount: number;\n  startIndex: number;\n  stopIndex: number;\n}): Indices[] {\n  const indices: Indices[] = [];\n\n  let currentStartIndex = -1;\n  let currentStopIndex = -1;\n\n  for (let index = startIndex; index <= stopIndex; index++) {\n    if (!isRowLoaded(index)) {\n      currentStopIndex = index;\n      if (currentStartIndex < 0) {\n        currentStartIndex = index;\n      }\n    } else if (currentStopIndex >= 0) {\n      indices.push({\n        startIndex: currentStartIndex,\n        stopIndex: currentStopIndex,\n      });\n\n      currentStartIndex = currentStopIndex = -1;\n    }\n  }\n\n  // Scan forward to satisfy the minimum batch size.\n  if (currentStopIndex >= 0) {\n    const potentialStopIndex = Math.min(\n      Math.max(currentStopIndex, currentStartIndex + minimumBatchSize - 1),\n      rowCount - 1\n    );\n\n    for (\n      let index = currentStopIndex + 1;\n      index <= potentialStopIndex;\n      index++\n    ) {\n      if (!isRowLoaded(index)) {\n        currentStopIndex = index;\n      } else {\n        break;\n      }\n    }\n\n    indices.push({\n      startIndex: currentStartIndex,\n      stopIndex: currentStopIndex,\n    });\n  }\n\n  // Check to see if our first range ended prematurely.\n  // In this case we should scan backwards to satisfy the minimum batch size.\n  if (indices.length) {\n    const firstIndices = indices[0];\n    while (\n      firstIndices.stopIndex - firstIndices.startIndex + 1 < minimumBatchSize &&\n      firstIndices.startIndex > 0\n    ) {\n      const index = firstIndices.startIndex - 1;\n      if (!isRowLoaded(index)) {\n        firstIndices.startIndex = index;\n      } else {\n        break;\n      }\n    }\n  }\n\n  return indices;\n}\n","import { useCallback, useMemo } from \"react\";\nimport { scanForUnloadedIndices } from \"./scanForUnloadedIndices\";\nimport type { Indices, OnRowsRendered, Props } from \"./types\";\n\nexport function useInfiniteLoader({\n  isRowLoaded,\n  loadMoreRows,\n  minimumBatchSize = 10,\n  rowCount,\n  threshold = 15,\n}: Props) {\n  const pendingRowsCache = useMemo(() => {\n    void isRowLoaded;\n    void loadMoreRows;\n\n    return new Set();\n  }, [isRowLoaded, loadMoreRows]);\n\n  const isRowLoadedOrPending = useCallback(\n    (index: number) => {\n      if (isRowLoaded(index)) {\n        return true;\n      }\n\n      return pendingRowsCache.has(index);\n    },\n    [isRowLoaded, pendingRowsCache]\n  );\n\n  const onRowsRendered = useCallback<OnRowsRendered>(\n    ({ startIndex, stopIndex }: Indices) => {\n      const unloadedIndices = scanForUnloadedIndices({\n        isRowLoaded: isRowLoadedOrPending,\n        minimumBatchSize,\n        rowCount,\n        startIndex: Math.max(0, startIndex - threshold),\n        stopIndex: Math.min(rowCount - 1, stopIndex + threshold),\n      });\n\n      for (let index = 0; index < unloadedIndices.length; index += 2) {\n        const { startIndex: unloadedStartIndex, stopIndex: unloadedStopIndex } =\n          unloadedIndices[index];\n\n        for (\n          let index = unloadedStartIndex;\n          index <= unloadedStopIndex;\n          index++\n        ) {\n          pendingRowsCache.add(index);\n        }\n\n        loadMoreRows(unloadedStartIndex, unloadedStopIndex);\n      }\n    },\n    [\n      isRowLoadedOrPending,\n      loadMoreRows,\n      minimumBatchSize,\n      pendingRowsCache,\n      rowCount,\n      threshold,\n    ]\n  );\n\n  return onRowsRendered;\n}\n","import type { OnRowsRendered, Props } from \"./types\";\nimport { useInfiniteLoader } from \"./useInfiniteLoader\";\n\nexport function InfiniteLoader({\n  children,\n  ...props\n}: Props & {\n  children: (paras: { onRowsRendered: OnRowsRendered }) => void;\n}) {\n  const onRowsRendered = useInfiniteLoader(props);\n\n  return children({ onRowsRendered });\n}\n"],"names":["scanForUnloadedIndices","isRowLoaded","minimumBatchSize","rowCount","startIndex","stopIndex","indices","currentStartIndex","currentStopIndex","index","potentialStopIndex","firstIndices","useInfiniteLoader","loadMoreRows","threshold","pendingRowsCache","useMemo","isRowLoadedOrPending","useCallback","unloadedIndices","unloadedStartIndex","unloadedStopIndex","InfiniteLoader","children","props","onRowsRendered"],"mappings":";AAEO,SAASA,EAAuB;AAAA,EACrC,aAAAC;AAAA,EACA,kBAAAC;AAAA,EACA,UAAAC;AAAA,EACA,YAAAC;AAAA,EACA,WAAAC;AACF,GAMc;AACZ,QAAMC,IAAqB,CAAA;AAE3B,MAAIC,IAAoB,IACpBC,IAAmB;AAEvB,WAASC,IAAQL,GAAYK,KAASJ,GAAWI;AAC/C,IAAKR,EAAYQ,CAAK,IAKXD,KAAoB,MAC7BF,EAAQ,KAAK;AAAA,MACX,YAAYC;AAAA,MACZ,WAAWC;AAAA,IAAA,CACZ,GAEDD,IAAoBC,IAAmB,OAVvCA,IAAmBC,GACfF,IAAoB,MACtBA,IAAoBE;AAa1B,MAAID,KAAoB,GAAG;AACzB,UAAME,IAAqB,KAAK;AAAA,MAC9B,KAAK,IAAIF,GAAkBD,IAAoBL,IAAmB,CAAC;AAAA,MACnEC,IAAW;AAAA,IAAA;AAGb,aACMM,IAAQD,IAAmB,GAC/BC,KAASC,KAGL,CAACT,EAAYQ,CAAK,GAFtBA;AAGE,MAAAD,IAAmBC;AAMvB,IAAAH,EAAQ,KAAK;AAAA,MACX,YAAYC;AAAA,MACZ,WAAWC;AAAA,IAAA,CACZ;AAAA,EACH;AAIA,MAAIF,EAAQ,QAAQ;AAClB,UAAMK,IAAeL,EAAQ,CAAC;AAC9B,WACEK,EAAa,YAAYA,EAAa,aAAa,IAAIT,KACvDS,EAAa,aAAa,KAC1B;AACA,YAAMF,IAAQE,EAAa,aAAa;AACxC,UAAI,CAACV,EAAYQ,CAAK;AACpB,QAAAE,EAAa,aAAaF;AAAA;AAE1B;AAAA,IAEJ;AAAA,EACF;AAEA,SAAOH;AACT;AC3EO,SAASM,EAAkB;AAAA,EAChC,aAAAX;AAAA,EACA,cAAAY;AAAA,EACA,kBAAAX,IAAmB;AAAA,EACnB,UAAAC;AAAA,EACA,WAAAW,IAAY;AACd,GAAU;AACR,QAAMC,IAAmBC,EAAQ,0BAIpB,IAAA,GACV,CAACf,GAAaY,CAAY,CAAC,GAExBI,IAAuBC;AAAA,IAC3B,CAACT,MACKR,EAAYQ,CAAK,IACZ,KAGFM,EAAiB,IAAIN,CAAK;AAAA,IAEnC,CAACR,GAAac,CAAgB;AAAA,EAAA;AAsChC,SAnCuBG;AAAA,IACrB,CAAC,EAAE,YAAAd,GAAY,WAAAC,QAAyB;AACtC,YAAMc,IAAkBnB,EAAuB;AAAA,QAC7C,aAAaiB;AAAA,QACb,kBAAAf;AAAA,QACA,UAAAC;AAAA,QACA,YAAY,KAAK,IAAI,GAAGC,IAAaU,CAAS;AAAA,QAC9C,WAAW,KAAK,IAAIX,IAAW,GAAGE,IAAYS,CAAS;AAAA,MAAA,CACxD;AAED,eAASL,IAAQ,GAAGA,IAAQU,EAAgB,QAAQV,KAAS,GAAG;AAC9D,cAAM,EAAE,YAAYW,GAAoB,WAAWC,EAAA,IACjDF,EAAgBV,CAAK;AAEvB,iBACMA,IAAQW,GACZX,KAASY,GACTZ;AAEA,UAAAM,EAAiB,IAAIN,CAAK;AAG5B,QAAAI,EAAaO,GAAoBC,CAAiB;AAAA,MACpD;AAAA,IACF;AAAA,IACA;AAAA,MACEJ;AAAA,MACAJ;AAAA,MACAX;AAAA,MACAa;AAAA,MACAZ;AAAA,MACAW;AAAA,IAAA;AAAA,EACF;AAIJ;AC9DO,SAASQ,EAAe;AAAA,EAC7B,UAAAC;AAAA,EACA,GAAGC;AACL,GAEG;AACD,QAAMC,IAAiBb,EAAkBY,CAAK;AAE9C,SAAOD,EAAS,EAAE,gBAAAE,GAAgB;AACpC;"}